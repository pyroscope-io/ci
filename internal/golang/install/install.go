package install

import (
	"bufio"
	"fmt"
	"os"
	"strings"
	"text/template"

	"github.com/pyroscope-io/client/pyroscope"
)

// TODO: maybe upstream should export this?
var AvailableProfileTypes = []pyroscope.ProfileType{
	pyroscope.ProfileCPU,
	pyroscope.ProfileInuseObjects,
	pyroscope.ProfileAllocObjects,
	pyroscope.ProfileInuseSpace,
	pyroscope.ProfileAllocSpace,
	pyroscope.ProfileGoroutines,
	pyroscope.ProfileMutexCount,
	pyroscope.ProfileMutexDuration,
	pyroscope.ProfileBlockCount,
	pyroscope.ProfileBlockDuration,
}

// Install Install the pyroscope agent into test packages
// It does that by recursively finding packages with tests
// Then it generates a `pyroscope_test.go` file for each package
// With the profile type and app name specified
func Install(basePath string, appName string, profileTypes []string) error {
	candidateFiles, err := FindCandidateFiles(basePath)
	if err != nil {
		return err
	}

	t1 := template.New("t1")
	t1, err = t1.Parse(`// Code generated by pyroscope.
package {{.PackageName }}

import (
	"github.com/pyroscope-io/client/pyroscope"
)

func init() {
	pyroscope.Start(pyroscope.Config{
		ProfileTypes:    []pyroscope.ProfileType{ {{ .ProfileTypes }} },
		ApplicationName: "{{ .ApplicationName }}",
	})
}
`)
	if err != nil {
		return err
	}

	// For each package
	// Generate a pyroscope_test.go file
	for _, v := range candidateFiles {
		output, err := os.Create(v.Path)
		if err != nil {
			return err
		}
		w := bufio.NewWriter(output)

		err = t1.Execute(w, struct {
			PackageName     string
			ApplicationName string
			ProfileTypes    string
		}{
			PackageName:     v.PackageName,
			ApplicationName: appName,
			ProfileTypes:    strings.Join(profileTypes, ", "),
		})

		if err != nil {
			return err
		}

		if err = w.Flush(); err != nil {
			return err
		}

		fmt.Println("Created file", v.Path)
	}

	return nil
}
