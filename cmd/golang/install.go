package golang

import (
	"bufio"
	"context"
	"flag"
	"fmt"
	"go/parser"
	"go/token"
	"os"
	"path"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/peterbourgon/ff/v3/ffcli"
	"github.com/pyroscope-io/client/pyroscope"
)

var availableProfileTypes = []pyroscope.ProfileType{
	pyroscope.ProfileCPU,
	pyroscope.ProfileInuseObjects,
	pyroscope.ProfileAllocObjects,
	pyroscope.ProfileInuseSpace,
	pyroscope.ProfileAllocSpace,
	pyroscope.ProfileGoroutines,
	pyroscope.ProfileMutexCount,
	pyroscope.ProfileMutexDuration,
	pyroscope.ProfileBlockCount,
	pyroscope.ProfileBlockDuration,
}

func installCmd() *ffcli.Command {
	installFlagSet := flag.NewFlagSet("install", flag.ExitOnError)
	profileTypesFlag := installFlagSet.String("profileTypes", "all", fmt.Sprintf("list of profileTypes, separated by comma. available types are: %s", availableProfileTypes))
	appName := installFlagSet.String("applicationName", "", "the name of the application")

	cmd := &ffcli.Command{
		Name:       "install",
		ShortUsage: "pyro-ci go install {packagePath}",
		ShortHelp:  "Installs the pyroscope agent into test packages",
		LongHelp: "Given a (list of) {packagePath}, it will recursively find all packages that contains tests." +
			"Then it will generate a `pyroscope_test.go` file for each package, using the configuration passed as cli flags from this command.",
		FlagSet: installFlagSet,
		Exec: func(_ context.Context, args []string) error {
			if len(args) <= 0 {
				return fmt.Errorf("at least one path needs to be specified")
			}

			profileTypes, err := stringToProfileTypes(*profileTypesFlag)
			if err != nil {
				return err
			}

			if *appName == "" {
				return fmt.Errorf("applicationName is required")
			}

			for _, a := range args {
				if err := install(a, *appName, profileTypes); err != nil {
					return err
				}
			}

			fmt.Println("installed.")
			return nil
		},
	}

	return cmd
}

func isTestFile(p string) bool {
	// TODO: is this enough?
	return strings.HasSuffix(p, "_test.go")
}

// TODO: take different profile types
func install(basePath string, appName string, profileTypes []string) error {
	type TestPackage struct {
		Path        string
		PackageName string
	}

	// Use a map to not have any duplicates
	testPackages := make(map[string]TestPackage)

	// Find all test files
	err := filepath.Walk(basePath,
		func(p string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if info.IsDir() {
				return nil
			}

			if isTestFile(p) {
				dirName, _ := filepath.Split(p)

				if _, ok := testPackages[dirName]; ok {
					return nil
				}

				// TODO: this is costly, we should optimize to do it just once per package
				//packageName := filepath.Base(dirName)
				packageName, err := getPackageFromFileTestFile(p)

				if err != nil {
					return err
				}

				testPackages[dirName] = TestPackage{
					Path:        dirName,
					PackageName: packageName,
				}
			}

			return nil
		})
	if err != nil {
		return err
	}

	t1 := template.New("t1")
	t1, err = t1.Parse(`// Code generated by pyroscope.
package {{.PackageName }}

import (
	"github.com/pyroscope-io/client/pyroscope"
)

func init() {
	pyroscope.Start(pyroscope.Config{
		ProfileTypes:    []pyroscope.ProfileType{ {{ .ProfileTypes }} },
		ApplicationName: "{{ .ApplicationName }}",
	})
}
`)
	if err != nil {
		return err
	}

	// For each package
	// Generate a pyroscope_test.go file
	for _, v := range testPackages {
		testFile := path.Join(v.Path, "pyroscope_test.go")
		output, err := os.Create(testFile)
		if err != nil {
			return err
		}
		w := bufio.NewWriter(output)

		err = t1.Execute(w, struct {
			PackageName     string
			ApplicationName string
			ProfileTypes    string
		}{
			PackageName:     v.PackageName,
			ApplicationName: appName,
			ProfileTypes:    strings.Join(profileTypes, ", "),
		})

		if err != nil {
			return err
		}

		if err = w.Flush(); err != nil {
			return err
		}

		fmt.Println("Created file", testFile)
	}

	return nil
}

func getPackageFromFileTestFile(fileName string) (string, error) {
	fset := token.NewFileSet()
	ast, err := parser.ParseFile(fset, fileName, nil, parser.PackageClauseOnly)
	if err != nil {
		return "", err
	}

	return ast.Name.Name, nil
}

func stringToProfileTypes(p string) ([]string, error) {
	if p == "all" {
		return []string{
			`pyroscope.ProfileCPU`,
			`pyroscope.ProfileInuseObjects`,
			`pyroscope.ProfileAllocObjects`,
			`pyroscope.ProfileInuseSpace`,
			`pyroscope.ProfileAllocSpace`,
			`pyroscope.ProfileGoroutines`,
			`pyroscope.ProfileMutexCount`,
			`pyroscope.ProfileMutexDuration`,
			`pyroscope.ProfileBlockCount`,
			`pyroscope.ProfileBlockDuration`,
		}, nil
	}

	types := strings.Split(p, ",")
	chosen := make([]string, 0)

	for _, profileType := range types {
		switch profileType {
		case "all":
			return nil, fmt.Errorf("type 'all' must be set alone")
		case "cpu":
			chosen = append(chosen, `pyroscope.ProfileCPU`)
		case "inuse_objects":
			chosen = append(chosen, `pyroscope.ProfileInuseObjects`)
		case "alloc_objects":
			chosen = append(chosen, `pyroscope.ProfileAllocObjects`)
		case "inuse_space":
			chosen = append(chosen, `pyroscope.ProfileInuseSpace`)
		case "alloc_space":
			chosen = append(chosen, `pyroscope.ProfileAllocSpace`)
		case "goroutines":
			chosen = append(chosen, `pyroscope.ProfileGoroutines`)
		case "mutex_count":
			chosen = append(chosen, `pyroscope.ProfileMutexCount`)
		case "mutex_duration":
			chosen = append(chosen, `pyroscope.ProfileMutexDuration`)
		case "block_count":
			chosen = append(chosen, `pyroscope.ProfileBlockCount`)
		case "block_duration":
			chosen = append(chosen, `pyroscope.ProfileBlockDuration`)
		}
	}

	if len(chosen) <= 0 {
		return nil, fmt.Errorf("at least a single valid profileType must be set")
	}

	return chosen, nil
}
